# ChatMind Pipeline Overview - Dual Layer Graph Strategy

## 🏗️ **Current Pipeline Structure**
```
ai_memory/
├── chatmind/           # Main application modules
│   ├── api/           # FastAPI backend with dual layer support
│   ├── data_ingestion/ # Extract and flatten ChatGPT exports
│   ├── embedding/     # Generate embeddings and cluster messages
│   ├── tagger/        # Auto-tagging with post-processing
│   ├── semantic_positioning/ # UMAP positioning for topics and chats
│   ├── neo4j_loader/  # Dual layer graph loading
│   └── utilities/     # Database maintenance scripts
├── data/              # Data storage and processing
├── demos/             # Demo scripts for testing
├── scripts/           # Test and utility scripts
├── docs/              # Documentation
├── run_pipeline.py    # Unified smart pipeline runner
└── requirements.txt   # Dependencies
```

## 🔄 **Core Pipeline Flow**

### **1. Data Ingestion** (`chatmind/data_ingestion/`)
- **Purpose:** Extract and flatten ChatGPT exports
- **Input:** Raw ChatGPT export files
- **Output:** `data/processed/chats.jsonl` (raw conversation data)
- **Script:** `extract_and_flatten.py`
- **Smart:** Only processes new ZIP files

### **2. Embedding & Clustering** (`chatmind/embedding/`)
- **Purpose:** Generate embeddings and cluster similar messages
- **Input:** Messages from `chats.jsonl`
- **Output:** `data/embeddings/chunks_with_clusters.jsonl` (chunked + embedded)
- **Script:** `embed_and_cluster_direct_incremental.py`
- **Smart:** Only embeds new messages, reclusters everything

### **3. Auto-Tagging** (`chatmind/tagger/`)
- **Purpose:** Tag chunks with semantic hashtags
- **Input:** Clustered chunks
- **Output:** `data/processed/tagged_chunks.jsonl`
- **Script:** `run_tagging_incremental.py`
- **Smart:** Only tags new chunks

### **3.5. Tag Post-Processing** (`chatmind/tagger/`)
- **Purpose:** Map tags to master list, normalize, and deduplicate
- **Input:** `tagged_chunks.jsonl`, `tags_master_list.json`
- **Output:** `data/processed/processed_tagged_chunks.jsonl`
- **Script:** `post_process_tags.py`
- **Note:** This step ensures tags are mapped to your master list where possible, but unmapped tags are kept unless filtered out.

### **4. Semantic Positioning** (`chatmind/semantic_positioning/`)
- **Purpose:** Generate 2D coordinates for topic and chat nodes using UMAP
- **Input:** **Processed tagged chunks** (`processed_tagged_chunks.jsonl`)
- **Output:** 
  - `data/processed/topics_with_coords.jsonl` (topic coordinates)
  - `data/processed/chats_with_coords.jsonl` (chat coordinates)
- **Scripts:** `apply_topic_layout.py`, `apply_chat_layout.py`
- **Smart:** Only processes when new tagged data exists

### **5. Neo4j Loading - Dual Layer Strategy** (`chatmind/neo4j_loader/`)
- **Purpose:** Load processed data into graph database with dual layer architecture
- **Input:** 
  - `chats.jsonl` (raw conversation data)
  - `processed_tagged_chunks.jsonl` (chunked + tagged data)
  - Topic and chat coordinates
- **Output:** Neo4j graph database with dual layer structure
- **Script:** `load_graph.py`
- **Smart:** Only loads when new data exists

**Dual Layer Architecture:**
- **Layer 1 (Raw):** Chat and Message nodes with full conversation structure
- **Layer 2 (Chunk):** Chunk nodes with embeddings, linked to source messages
- **Semantic Layer:** Tags and Topics with cross-layer relationships
- **Cross-Layer:** HAS_CHUNK relationships connect raw messages to semantic chunks

### **6. API & Frontend** (`chatmind/api/` & `chatmind/frontend/`)
- **Purpose:** Visualization and interaction with dual layer support
- **API:** FastAPI backend with layer-specific endpoints
- **Frontend:** React + TypeScript + Material-UI

---

## 🏷️ **Tag Flow & Tag Count Explained**

- **Tagging Step:**
  - Tags are generated for each chunk (message) by the auto-tagger.
  - Output: `tagged_chunks.jsonl` (raw tags, may include tags not in your master list)

- **Tag Post-Processing:**
  - Each tag is mapped to your master list (`tags_master_list.json`) if possible.
  - Tags are normalized (case, prefix, etc.) and deduplicated.
  - Unmapped tags are kept unless you choose to filter them out.
  - Output: `processed_tagged_chunks.jsonl` (final tags for each chunk)

- **Downstream Steps:**
  - **Semantic positioning** and **Neo4j loading** now use `processed_tagged_chunks.jsonl` as their input.
  - **Neo4j** creates a Tag node for every unique tag string found in all chunks in `processed_tagged_chunks.jsonl`.

- **Tag Count in Dashboard/Neo4j:**
  - The number shown (e.g., 2,067) is the count of **unique tag names** (after mapping/normalization) actually present in your processed data, not just those in your master list.
  - This may be higher than your master list if new, unmapped tags are generated by the tagger and kept in the data.

---

## 📊 **Data Files**

### **Raw Data**
- `data/raw/` - ChatGPT export ZIP files
- `data/processed/chats.jsonl` - Flattened chat data (raw conversations)

### **Processed Data**
- `data/embeddings/chunks_with_clusters.jsonl` - Messages with embeddings and clusters
- `data/processed/tagged_chunks.jsonl` - Tagged chunks (raw tags)
- `data/processed/processed_tagged_chunks.jsonl` - **Post-processed, mapped, and normalized tags**
- `data/processed/topics_with_coords.jsonl` - Topics with 2D coordinates
- `data/processed/chats_with_coords.jsonl` - Chats with 2D coordinates

### **Tag Management**
- `data/tags/tags_master_list.json` - Master tag list (e.g., 755 tags)
- `data/interim/tag_frequencies_final.json` - Final tag frequencies
- `data/interim/missing_tags_report.json` - Tags not mapped to master list

### **State Tracking**
- `data/processed/message_embedding_state.pkl` - Tracks embedded messages
- `data/processed/chunk_tagging_state.pkl` - Tracks tagged chunks
- `data/processed/content_hashes.pkl` - Tracks processed ZIP files

### **Cost Tracking**
- `data/cost_tracker.db` - API usage tracking

---

## 🏗️ **Dual Layer Graph Schema**

### **Layer 1: Raw Layer (No Chunking)**
**Nodes:**
- `(:Chat {chat_id, title, create_time, update_time, data_lake_id, x, y})`
- `(:Message {message_id, content, role, timestamp, chat_id})`

**Relationships:**
- `(Chat)-[:CONTAINS]->(Message)` - Chat contains this message
- `(Message)-[:REPLIES_TO]->(Message)` - Message is a reply to another message (optional threading)

### **Layer 2: Chunk Layer (Chunked + Embedded)**
**Nodes:**
- `(:Chunk {chunk_id, text, embedding, source_message_id, cluster_id, chat_id})`

**Relationships:**
- `(Message)-[:HAS_CHUNK]->(Chunk)` - Message has been chunked into semantic pieces

### **Semantic Layer (Tags & Topics)**
**Nodes:**
- `(:Tag {name, count})` - Semantic tags/categories
- `(:Topic {topic_id, name, size, top_words, sample_titles, x, y})` - Semantic clusters

**Relationships:**
- `(Chunk)-[:TAGGED_WITH]->(Tag)` - Chunk is tagged with category
- `(Topic)-[:SUMMARIZES]->(Chunk)` - Topic summarizes/represents this chunk
- `(Chat)-[:HAS_TOPIC]->(Topic)` - Chat contains messages from this topic
- `(Chat)-[:SIMILAR_TO]->(Chat)` - Chats are semantically similar

---

## 📝 **Replication Checklist**
- Always run the tag post-processing step after tagging and before any downstream steps.
- Downstream steps (topic layout, Neo4j loader) must use `processed_tagged_chunks.jsonl` as their input, not the raw `tagged_chunks.jsonl`.
- If you update your tag mapping logic or master list, re-run post-processing and reload downstream.
- The dual layer strategy preserves both raw conversation structure and semantic analysis capabilities.
- **HAS_CHUNK relationships are now automatically created during the Neo4j loading pipeline.**

---

## 🚀 **Usage**

### **Run Complete Smart Pipeline**
```bash
python run_pipeline.py
```

### **Check What Needs Processing**
```bash
python run_pipeline.py --check-only
```

### **Run Individual Steps**
```bash
# Data ingestion
python chatmind/data_ingestion/extract_and_flatten.py

# Embedding & clustering
python chatmind/embedding/embed_and_cluster_direct_incremental.py

# Auto-tagging
python chatmind/tagger/run_tagging_incremental.py

# Tag post-processing
python chatmind/tagger/post_process_tags.py

# Semantic positioning
python chatmind/semantic_positioning/apply_topic_layout.py
python chatmind/semantic_positioning/apply_chat_layout.py

# Neo4j loading (dual layer)
python chatmind/neo4j_loader/load_graph.py
```

### **Start Services**
```bash
python scripts/start_services.py
```

### **Run Demos**
```bash
# Test auto-tagging
python demos/demo_auto_tagging.py

# Test semantic chunking
python demos/demo_semantic_chunking.py

# Test cost tracking
python demos/demo_cost_tracking.py

# Test data lake
python demos/demo_data_lake.py
```

### **Database Maintenance**
```bash
# Create HAS_CHUNK relationships (if needed)
python chatmind/utilities/create_has_chunk_relationships.py

# Create chat similarity relationships (if needed)
python chatmind/utilities/create_chat_similarity.py
```

## 📈 **Pipeline Statistics**

- **Total Messages:** ~40,556 (user + assistant)
- **Total Chunks:** ~32,565 (semantic pieces)
- **Total Chats:** ~1,714 conversations
- **Total Topics:** ~1,198 semantic clusters
- **Master Tags:** 755 unique tags
- **Active Tags:** 2,067 unique tags in data
- **Tag Coverage:** 70.9% mapping rate
- **Processing Time:** ~2.5 hours for full tagging
- **Smart Processing:** 90%+ time savings for incremental updates

## 🎯 **Current Status**

✅ **Pipeline is unified and smart**  
✅ **Dual layer graph strategy implemented**  
✅ **All components are actively used**  
✅ **Demo scripts organized in `demos/`**  
✅ **Tag system normalized and consistent**  
✅ **Ready for production use**  
✅ **Automatic incremental processing**  
✅ **Preserves both raw conversations and semantic analysis**  
✅ **HAS_CHUNK relationships automatically created**  
✅ **Chat similarity relationships automatically created**  
✅ **UMAP positioning for topics and chats**  
✅ **All test scripts passing (7/7)**  
⚠️ **Graph endpoint needs optimization for edge visualization**

## 🔍 **Query Examples**

### **Raw Layer Queries**
```cypher
-- Get complete conversation
MATCH (c:Chat {chat_id: "chat_123"})-[:CONTAINS]->(m:Message)
RETURN c, collect(m) as messages
ORDER BY m.timestamp

-- Search raw messages
MATCH (m:Message)
WHERE toLower(m.content) CONTAINS toLower("python")
RETURN m.content, m.role, m.timestamp
ORDER BY m.timestamp DESC
```

### **Chunk Layer Queries**
```cypher
-- Get chunks for a message
MATCH (m:Message {message_id: "msg_456"})-[:HAS_CHUNK]->(ch:Chunk)
OPTIONAL MATCH (ch)-[:TAGGED_WITH]->(tag:Tag)
RETURN ch, collect(tag) as tags

-- Semantic search by tags
MATCH (ch:Chunk)-[:TAGGED_WITH]->(tag:Tag {name: "python"})
RETURN ch.text, ch.source_message_id, tag.name
```

### **Cross-Layer Queries**
```cypher
-- Get message with semantic analysis
MATCH (m:Message {message_id: "msg_456"})
OPTIONAL MATCH (m)-[:HAS_CHUNK]->(ch:Chunk)
OPTIONAL MATCH (ch)-[:TAGGED_WITH]->(tag:Tag)
OPTIONAL MATCH (ch)<-[:SUMMARIZES]-(t:Topic)
RETURN m.content, collect(ch.text) as chunks, collect(tag.name) as tags, t.name as topic
```

### **Semantic Layer Queries**
```cypher
-- Find similar chats
MATCH (c1:Chat)-[:SIMILAR_TO]-(c2:Chat)
WHERE c1.chat_id = "chat_123"
RETURN c2.title, c2.chat_id, c1.similarity
ORDER BY c1.similarity DESC

-- Get topics with coordinates
MATCH (t:Topic)
WHERE t.x IS NOT NULL AND t.y IS NOT NULL
RETURN t.name, t.x, t.y, t.size
```

---

*The Dual Layer Graph Strategy provides comprehensive capabilities for both traditional conversation analysis and modern AI-powered semantic search, enabling users to explore ChatGPT data across multiple dimensions while preserving the original conversation structure.* 